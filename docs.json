[{"name":"Validation","comment":"\n\n@docs Validation\n@docs run\n\n\n## Create\n\n@docs filter, fromPartialFunction\n\n\n## Black magic\n\nFunctor, Applicative, Contravariant, Monad interfaces\n\n@docs succeed, fail, map, contramap, map2, andMap, andThen\n@docs andMapWith\n\n","unions":[],"aliases":[{"name":"Validation","comment":" An abstraction representing a validation from a type to another.\nShould fail when the previous step fails\n\n    Date.fromString : String -> Result String Date\n\n    validateDate : Validation String Date\n    validateDate =\n        Result.andThen Date.fromIsoString\n\nYou can compose `Validation`s via regular function composition (or pipe operator)\n\n    validateStringNonEmpty : Validation String String\n    validateStringNonEmpty =\n        Validation.String.notEmpty \"This field is required\"\n\n    validateYearIsAtLeast1900 : Validation Date Date\n\n    yearFieldValidation : Validation String Date\n    yearFieldValidation =\n        validateStringNonEmpty >> validateDate >> validateYearIsAtLeast1900\n\n","args":["from","to"],"type":"Result.Result String.String from -> Result.Result String.String to"}],"values":[{"name":"andMap","comment":" ","type":"Validation.Validation from a -> Validation.Validation from (a -> b) -> Validation.Validation from b"},{"name":"andMapWith","comment":" ","type":"(a -> value) -> Validation.Validation value b -> Validation.Validation a (b -> c) -> Validation.Validation a c"},{"name":"andThen","comment":" ","type":"(a -> Validation.Validation from b) -> Validation.Validation from a -> Result.Result String.String from -> Result.Result String.String b"},{"name":"contramap","comment":" ","type":"(a -> b) -> Validation.Validation b to -> Validation.Validation a to"},{"name":"fail","comment":" ","type":"String.String -> Result.Result String.String from -> Result.Result String.String to"},{"name":"filter","comment":" Lifts a predicate to a validation\n\n    stringHas4Chars : String -> Validation String String\n    stringHas4Chars =\n        Validation.fromPredicate (\\str -> String.length str == 4)\n\n    \"ab\"\n    |> Validation.run (stringHas4Chars \"string should have 4 chars\")\n    |> Expect.equal (Err \"string should have 4 chars\")\n\n    \"abcd\"\n    |> Validation.run (stringHas4Chars \"...\")\n    |> Expect.equal (Ok \"abcd\")\n\n","type":"(a -> Basics.Bool) -> String.String -> Validation.Validation a a"},{"name":"fromPartialFunction","comment":" Lifts a partial function to a validation\n\n    -- The actual definition of `Validation.String.toInt`\n    validateInt : String -> Validation String Int\n    validateInt =\n        Validation.fromPartialFunction String.toInt\n\n","type":"(from -> Maybe.Maybe to) -> String.String -> Validation.Validation from to"},{"name":"map","comment":" ","type":"(a -> b) -> Validation.Validation from a -> Validation.Validation from b"},{"name":"map2","comment":" ","type":"(a -> b -> c) -> Validation.Validation from a -> Validation.Validation from b -> Result.Result String.String from -> Result.Result String.String c"},{"name":"run","comment":" Runs a validation and returns a `Result`\n\n    Validation.run yearFieldValidation \"\"\n        |> Expect.equal (Err \"This field is required\")\n\n    Validation.run yearFieldValidation \"invalid year...\"\n        |> Expect.equal (Err \"Enter a valid year\")\n\n    Validation.run yearFieldValidation \"1800-09-26\"\n        |> Expect.equal (Err \"Year must be at least 1900\")\n\n    Validation.run yearFieldValidation \"2018-09-26\"\n        |> Expect.equal (Ok ...)\n\n","type":"Validation.Validation from to -> from -> Result.Result String.String to"},{"name":"succeed","comment":" ","type":"to -> Result.Result String.String from -> Result.Result String.String to"}],"binops":[]},{"name":"Validation.Number","comment":" Validations over the `number` type\n\n\n## Predicates\n\n@docs min, max\n\n","unions":[],"aliases":[],"values":[{"name":"max","comment":" ","type":"number -> String.String -> Validation.Validation number number"},{"name":"min","comment":" ","type":"number -> String.String -> Validation.Validation number number"}],"binops":[]},{"name":"Validation.String","comment":" Validations over the `String` type\n\n\n## Predicates\n\n@docs any, notEmpty, minLength, maxLength\n\n\n## Transformations\n\n@docs toInt, toFloat, trim\n\n\n## Higher order validations\n\n@docs optional\n\n","unions":[],"aliases":[],"values":[{"name":"any","comment":" Only succeeds when the given predicate matches at least one char\n","type":"(Char.Char -> Basics.Bool) -> String.String -> Validation.Validation String.String String.String"},{"name":"maxLength","comment":" Only succeeds when the string has at most n chars\n","type":"Basics.Int -> String.String -> Validation.Validation String.String String.String"},{"name":"minLength","comment":" Only succeeds when the string has at least n chars\n","type":"Basics.Int -> String.String -> Validation.Validation String.String String.String"},{"name":"notEmpty","comment":" Only succeeds when the string is not empty\n","type":"String.String -> Validation.Validation String.String String.String"},{"name":"optional","comment":" Succeeds with `Nothing` when the given string is empty, else wraps it with Just\n","type":"Validation.Validation String.String to -> Validation.Validation String.String (Maybe.Maybe to)"},{"name":"toFloat","comment":" Parses a float\n","type":"String.String -> Validation.Validation String.String Basics.Float"},{"name":"toInt","comment":" Parses an int\n","type":"String.String -> Validation.Validation String.String Basics.Int"},{"name":"trim","comment":" Trims the given string. Always succeeds.\n","type":"Validation.Validation String.String String.String"}],"binops":[]}]